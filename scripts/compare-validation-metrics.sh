#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 2 ]]; then
  echo "usage: $0 <baseline.log> <candidate.log>" >&2
  exit 2
fi

baseline="$1"
candidate="$2"

extract() {
  local file="$1" key="$2"
  # Expect lines like: "False Positive Rate: 23.68%" or "F1 Score: 0.6351"
  # Normalize key spacing
  grep -E "^${key}:" "$file" | head -n1 | awk -F': ' '{print $2}' | tr -d '%' || true
}

percent_change() {
  local base="$1" new="$2"
  if [[ "$base" == "0" ]]; then echo "0"; return; fi
  awk -v b="$base" -v n="$new" 'BEGIN { printf("%.2f", ((n-b)/b)*100) }'
}

metrics=("False Positive Rate" "True Positive Rate" "Precision" "F1 Score")
# Use name-mangled variables instead of associative arrays for macOS bash 3.2 compatibility
for k in "${metrics[@]}"; do
  vbase=$(extract "$baseline" "$k" | tr -d ' ' | sed 's/%$//' || true)
  vcand=$(extract "$candidate" "$k" | tr -d ' ' | sed 's/%$//' || true)
  var_b=${k// /_}_BASE
  var_n=${k// /_}_NEW
  # shellcheck disable=SC2140
  eval "$var_b=\"$vbase\""
  # shellcheck disable=SC2140
  eval "$var_n=\"$vcand\""
done

# Header
echo "## Fingerprint Validation Results"
echo ""
echo "### Metrics Comparison (vs. main)"
echo ""
echo "| Metric | Main | PR | Change | Status |"
echo "|--------|------|----|--------|--------|"

status=0
threshold=5 # percent

for k in "${metrics[@]}"; do
  var_b=${k// /_}_BASE
  var_n=${k// /_}_NEW
  # Safely read dynamic variable values (bash 3.2 compatible)
  # shellcheck disable=SC2016
  b=$(eval "printf '%s' \"\${$var_b:-}\"")
  # shellcheck disable=SC2016
  n=$(eval "printf '%s' \"\${$var_n:-}\"")
  if [[ -z "$b" || -z "$n" ]]; then
    echo "| $k | - | - | - | ⚠️ missing |"
    continue
  fi

  # For FPR lower is better; for others higher is better
  change=$(percent_change "$b" "$n")
  arrow="↑"; color="✅ Improved"; regressed=0
  if [[ "$k" == "False Positive Rate" ]]; then
    # Lower is better
    if awk -v c="$change" 'BEGIN{exit !(c<0)}'; then
      arrow="↓"; color="✅ Improved"; regressed=0
    else
      arrow="↑"; color="❌ Regressed"; regressed=1
    fi
  else
    # Higher is better
    if awk -v c="$change" 'BEGIN{exit !(c>0)}'; then
      arrow="↑"; color="✅ Improved"; regressed=0
    else
      arrow="↓"; color="❌ Regressed"; regressed=1
    fi
  fi

  # Hard fail on >$threshold% relative regression (directionally)
  if [[ $regressed -eq 1 ]]; then
    if awk -v c="$change" -v t="$threshold" 'BEGIN{c=(c<0)?-c:c; exit !(c>t)}'; then
      status=1
    fi
  fi

  printf "| %s | %s | %s | %s%% %s | %s |\n" "$k" "$b" "$n" "$change" "$arrow" "$color"
done

echo ""
echo "> This comment is auto-generated by CI. Regressions >5% will fail the job."

exit $status
